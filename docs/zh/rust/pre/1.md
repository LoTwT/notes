# 内存：值放堆上还是放栈上

## 内存

```rust
let s = "hello world".to_string();
```

上面的这条语句，跟只读数据段 ( RODATA ) 、堆、栈分别有深度交互：

1. `hello world` 作为字符串常量 ( string literal )，在编译时被存入可执行文件的 `.RODATA` 段 ( GCC ) 或 `.RDATA` 段 ( VC++ )，在程序加载时，获得一个固定的内存地址
1. 执行 `"hello world".to_string()` 时，在堆上，一块新的内存被分配出来，并把 `hello world` 逐个字节拷贝过去
1. 当把堆上的数据复制给 `s` 时，`s` 作为分配在栈上的一个变量，它需要知道堆上内存的地址；由于堆上的数据大小不确定且可以增长，还需要知道它的长度以及它现在有多大

最终，**为了表述这个字符串，使用了三个 word**：

1. 表示指针
1. 表示字符串的当前长度 ( 11 )
1. 表示这片内存的总容量 ( 11 )

在 64 位系统下，三个 word 是 24 字节。

## 栈

栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被成为帧 ( frame ) 。

栈自顶向下增长。一个程序的调用栈最底部，除去入口帧 ( entry frame ) ，就是 `main()` 函数对应的帧，随着 `main()` 函数的一层层调用，栈会一层层扩展；调用结束，栈会一层层回溯，释放内存。

调用过程中，**一个新的帧会分配足够的空间存储寄存器的上下文**。在函数里使用到的通用寄存器会在栈保存一个副本，当函数调用结束，通过副本，可以恢复原本的寄存器的上下文。函数所需要使用到的局部变量，也都会在帧分配的时候被预留。

![](/rust/pre-stack.jpg)

函数运行时，如何确定需要多大的帧呢？

归功于编译器，在编译并优化代码的时候，一个函数就是一个最小的编译单元。

在这个函数里，编译器得知道用到哪些寄存器、栈上要放哪些局部变量，这些都在编译时确定。所以编译器需要明确每个局部变量的大小，以便于预留空间。

所以：**在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。**

例如：

```rust
fn say_name(name: String) {}

// 调用
say_name("zhangsan".to_string());
say_name("lisi".to_string());
```

函数的参数是字符串时，在编译时大小不确定，运行时执行到具体的代码才知道大小。

所以，无法把字符串本身放在栈上，只能先将其放在堆上，然后在栈上分配对应的指针，引用堆上的内存。

但参数类型是数值类型，如 `int` 时，无论参数是什么值，占用内存都是固定的。

## 栈溢出

栈上的内存分配是非常高效的。

栈空间的调整是通过移动栈指针实现的。

只要改动栈指针 ( stack pointer )，就可以预留相应的空间；改回栈指针，预留的空间又会被释放。预留和释放只是动动寄存器，不涉及额外计算、不涉及系统调用，所以效率很高。

理论上，把变量分配到栈上，可以获得更好的运行速度。但实际上，需要避免把大量的数据分配在栈上。

原因是考虑到调用栈的大小，避免栈溢出 ( stack overflow )。

一旦当前程序的调用栈超出了系统允许的最大栈空间，无法创建新的帧来运行下一个要执行的函数，就会发生栈溢出，这时程序会被系统终止，产生崩溃信息。

过大的栈内存分配是导致栈溢出的原因之一，更多的原因是**递归函数没有妥善终止**。一个递归函数不断调用自己，每次调用都会形成一个新的帧，如果递归函数无法终止，最终就会导致栈溢出。
