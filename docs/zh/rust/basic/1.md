# 初窥门径：第一个 Rust 程序！

## 环境安装

Windows 按照 <https://rustup.rs/> 的指示安装即可。

因为运行 Rust 程序需要 Visual C++ Build Tools ，遵循命令行提示下载即可，注意勾选 Windows SDK 。

选用 VS Code 时，可选择以下插件：

1. rust-analyzer / Rust 官方插件 ：实时编译和分析 Rust 代码，提示代码错误，并对类型进行标注 ( 需写分号 )
1. rust syntax ：语法高亮
1. crates ：帮助分析当前项目的依赖是否是最新的版本
1. better toml ：Rust 使用 toml 做项目的配置管理。better toml 提供语法高亮，并展示 toml 文件中的错误

## 第一个 Rust 程序

通过 HTTP 请求 Rust 官网首页，把获得的 HTML 转换成 Markdown 保存。

[html2md-rs](https://github.com/LoTwT/html2md-rs)

- `cargo new <project_name>` ： 新建 Rust 项目
- `cargo run` ：运行

## 基本特点

Rust 使用 cargo 管理项目，它类似于 Node.js 的 npm 、Golang 的 go，用来做依赖管理以及开发过程中的任务管理，比如编译、运行、测试、代码格式化等。

Rust 的整体语法偏 C / C++ 风格：

1. 函数体用 `{}` 包裹
1. 表达式之间用分号 `;` 分隔
1. 访问结构体打的成员函数或者变量使用 `.` 运算符
1. 访问命名空间 ( namespace ) 或者对象的静态函数使用双冒号 `::` 运算符
1. 简化对命名空间内部的函数或者数据类型的引用，使用 `use` 关键字，比如 `use std::fs`
1. 可执行体的入口函数是 `main()`

Rust 是一门强类型语言，但编译器支持类型推导，这使得开发时的直观感受和写脚本语言差不多。

Rust 支持宏编程。很多基础功能，如 `println!()` 被封装成一个宏，便于写出更简洁的代码。

Rust 的其他特点：

1. Rust 的变量默认是不可变的，需要显式地使用 `mut` 关键字才能修改变量的值
1. 除了 let / static / const /fn 等少数语句外，Rust 绝大多数代码都是表达式 ( expression ) 。所以 if / while / for / loop 都会返回一个值，函数最后一个表达式就是函数的返回值，和函数式编程语言一致
1. Rust 支持面向接口编程和泛型编程
1. Rust 有非常丰富的数据类型和强大的标准库
1. Rust 有非常丰富的控制流程，包括模式匹配 ( pattern match )

## 基本内容

![basic content](/rust/basic-content.jpg)

### 变量

Rust 支持类型推导，在编译器能够推导类型的情况下，变量类型一般可以省略，但常量 ( const ) 和静态变量 ( static ) 必须声明类型。

定义变量时，可以根据需要，添加 `mut` 关键字让变量具备可变性。**变量默认不可变**。它符合最小权限原则 ( Principle of Least Privilege ) ，有助于写出健壮且正确的代码。当使用 `mut` 却没有修改变量，Rust 会在编译期友好的报警，提示移除不必要的 `mut` 。

### 函数

在 Rust 下，函数是一等公民，可以作为参数或者返回值。

```rust
fn apply(value: i32, f: fn(i32) -> i32) -> i32 {
  f(value)
}

fn square(value: i32) -> i32 {
  value * value
}

fn cube(value: i32) -> i32 {
  value * value * value
}

fn main() {
  println!("apply square: {}", apply(2, square));
  println!("apply cube: {}", apply(2, cube));
}
```

`fn(i32) -> i32` 是 apply 函数第二个参数的类型，它表明接收一个函数作为参数，这个传入的函数必须是：参数只有一个，类型为 i32 ，返回值类型为 i32 。

Rust 函数参数的类型和返回值的类型都必须显示定义，如果没有返回值可以省略，返回 unit 。函数内部如果提前返回，需要用 `return` 关键字，否则最后一个表达式就是其返回值。如果最后一个表达式后添加了 `;` 分号，隐含其返回值为 unit 。

```rust
fn pi() -> f64 {
  3.1415926
}

fn not_pi() {
  3.1415926;
}

fn main() {
  let is_pi = pi();
  let is_unit1 = not_pi();
  let is_unit2 = {
    pi();
  };

  println!("is_pi: {:?}, is_unit1: {:?}, is_unit2: {:?}", is_pi, is_unit1, is_unit2);
}
```

## 数据结构

数据结构是程序的核心组成部分，在对复杂的问题进行建模时，需要自定义数据结构。

Rust 非常强大，可以用 struct 定义结构体，用 enum 定义标签联合体 ( tagged union ) ，还可以像 Python 一样随手定义元组 ( tuple ) 。

比如一个聊天服务的数据结构

```rust
#[derive(Debug)]
enum Gender {
  Unspecified = 0,
  Female = 1,
  Male = 2,
}

#[derive(Debug, Copy, Clone)]
struct UserId(u64);

#[derive(Debug, Copy, Clone)]
struct TopicId(u64);

#[derive(Debug)]
struct User {
  id: UserId,
  name: String,
  gender: Gender,
}

#[derive(Debug)]
struct Topic {
  id: TopicId,
  name: String,
  owner: UserId,
}

// 定义聊天室中可能发生的事件
#[derive(Debug)]
enum Event {
  Join((UserId, TopicId)),
  Leave((UserId, TopicId)),
  Message((UserId, TopicId, String)),
}

fn main() {
  let alice = User { id: UserId(1), name: "Alice".into(), gender: Gender::Female };
  let bob = User { id: UserId(2), name: "Bob".into(), gender: Gender::Male };

  let topic = Topic { id:TopicId(1), name: "rust".into(), owner: UserId(1) };
  let event1 = Event::Join((alice.id, topic.id));
  let event2 = Event::Join((bob.id, topic.id));
  let event3 = Event::Join((alice.id, topic.id, "Hello World!".into()));

  println!("event1: {:?}, event2: {:?}, event3: {:?}", event1, event2, event3);
}
```

解释：

1. Gender ：枚举类型，在 Rust 下，使用 enum 可以定义类似 C 的枚举类型
1. UserId / TopicId ：struct 的特殊形式，称为元组结构体。它的域都是匿名的，可以用索引访问，适用于简单的结构体。
1. User / Topic ：标准的结构体，可以把任何类型组合在结构体里使用。
1. Event ：标准的标签联合体，它定义了三种事件：Join、Leave、Message 。每种事件都有各自的数据结构。

定义数据结构时，一会会加入修饰，为数据结构引入一些额外的行为。

在 Rust 里，数据的行为通过 trait 定义，暂时可以认为 trait 定义了数据结构可以实现的结构。

一般用 impl 关键字为数据结构实现 trait ，但 Rust 也提供了派生宏 ( derive macro ) ，可以大大简化一些标准接口的定义，比如 `#[derive(Debug)]` 为数据结构实现了 [Debug trait](https://doc.rust-lang.org/std/fmt/trait.Debug.html) ，提供了 debug 能力，因此可以通过 `{:?}` ，用 `println!` 打印出来。

在定义 UserId / TopicId 时，还用到了 Copy / Clone 两个派生宏，Clone 让数据结构可以被复制，而 Copy 则让数据结构可以在参数传递的时候自动按字节拷贝。

![](/rust/basic-data-structure.jpg)
